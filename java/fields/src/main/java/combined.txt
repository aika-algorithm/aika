
package network.aika.exceptions;

/**
 *
 * @author Lukas Molzberger
 */
public class TimeoutException extends RuntimeException {
}

package network.aika.fields;

import network.aika.fields.defs.FieldLinkDefinitionOutputSide;
import network.aika.fields.defs.FixedArgumentsFieldDefinition;
import network.aika.fields.field.Field;
import network.aika.fields.defs.FieldLinkDefinition;
import network.aika.type.Obj;
import network.aika.type.Type;

/**
 *
 * @author Lukas Molzberger
 */
public abstract class AbstractFunctionDefinition extends FixedArgumentsFieldDefinition {

    public AbstractFunctionDefinition(Type objectType, String name, int numArgs) {
        super(objectType, name, numArgs);
    }

    public AbstractFunctionDefinition(Type objectType, String name, int numArgs, double tolerance) {
        super(objectType, name, numArgs, tolerance);
    }

    protected abstract double computeUpdate(Obj obj, FieldLinkDefinitionOutputSide fl, double u);

    @Override
    public void transmit(Field targetField, FieldLinkDefinitionOutputSide fl, double u) {
        double update = computeUpdate(targetField.getObject(), fl, u);

        receiveUpdate(targetField, update);
    }
}


package network.aika.fields;

/**
 *
 * @author Lukas Molzberger
 */
public interface ActivationFunction {

    double f(double x);

    double outerGrad(double x);
}


package network.aika.fields;

import network.aika.fields.defs.FieldLinkDefinitionOutputSide;
import network.aika.type.Type;
import network.aika.type.Obj;

/**
 * @author Lukas Molzberger
 */
public class Addition extends AbstractFunctionDefinition {

    public static Addition add(Type ref, String name) {
        return new Addition(
                ref,
                name
        );
    }

    public Addition(Type ref, String name) {
        super(ref, name, 2);
    }

    @Override
    protected double computeUpdate(Obj obj, FieldLinkDefinitionOutputSide fl, double u) {
        return u;
    }
}


package network.aika.fields;

import network.aika.fields.defs.FieldLinkDefinitionOutputSide;
import network.aika.fields.field.Field;
import network.aika.type.Obj;
import network.aika.type.Type;

/**
 * @author Lukas Molzberger
 */
public class Division extends AbstractFunctionDefinition {

    public static Division div(Type ref, String name) {
        return new Division(
                ref,
                name
        );
    }

    public Division(Type ref, String name) {
        super(ref, name, 2);
    }

    @Override
    public void initializeField(Field field) {
        Obj toObj = field.getObject();
        double dividend = getInputValueByArg(toObj, 0);
        double divisor = getInputValueByArg(toObj, 1);

        if(divisor == 0.0)
            return;

        field.setValue(dividend / divisor);
    }

    @Override
    protected double computeUpdate(Obj obj, FieldLinkDefinitionOutputSide fl, double u) {
        if(fl.getArgument() == 0) {
            double divisor = getInputValueByArg(obj, 1);
            if(divisor == 0.0)
                return 0.0;

            return u / divisor;
        } else {
            double dividend = getInputValueByArg(obj, 0);
            double divisor = getUpdatedInputValueByArg(obj,1);
            if(divisor == 0.0)
                return 0.0;

            double oldValue = obj.getFieldValue(this);
            return (dividend / divisor) - oldValue;
        }
    }
}


package network.aika.fields;

import network.aika.fields.defs.FieldDefinition;
import network.aika.fields.defs.FixedArgumentsFieldDefinition;
import network.aika.fields.field.Field;
import network.aika.type.Obj;
import network.aika.type.Type;

import java.util.function.BiConsumer;

/**
 * @author Lukas Molzberger
 */
public class EventListener extends FixedArgumentsFieldDefinition {

    private BiConsumer<FieldDefinition, Obj> triggerFunction;

    public static EventListener eventListener(Type ref, String name, BiConsumer<FieldDefinition, Obj> triggerFunction, Double tolerance) {
        return new EventListener(
                ref,
                name,
                triggerFunction,
                tolerance
        );
    }

    public EventListener(Type ref, String name, BiConsumer<FieldDefinition, Obj> triggerFunction, Double tolerance) {
        super(ref, name, 1, tolerance);

        this.triggerFunction = triggerFunction;
    }

    @Override
    public void receiveUpdate(Field field, double u) {
        super.receiveUpdate(field, u);
       // Activation act = (Activation) obj;

        //Field field = obj.getFieldOrCreate(this);
        //act.updateFiredStep(field);

        triggerFunction.accept(this, field.getObject());
    }
}
/*


package network.aika.fields;

import network.aika.fields.defs.FieldLinkDefinitionOutputSide;
import network.aika.fields.field.Field;
import network.aika.type.Obj;
import network.aika.type.Type;

/**
 * @author Lukas Molzberger
 */
public class ExponentialFunction extends AbstractFunctionDefinition {

    public static ExponentialFunction exp(Type ref, String name) {
        return new ExponentialFunction(
                ref,
                name
        );
    }

    public ExponentialFunction(Type ref, String name) {
        super(ref, name, 1);
    }

    @Override
    public void initializeField(Field field) {
        double valueArg0 = getInputValueByArg(field.getObject(), 0);

        field.setValue(Math.exp(valueArg0));
    }

    @Override
    protected double computeUpdate(Obj obj, FieldLinkDefinitionOutputSide fl, double u)  {
        return Math.exp(getUpdatedInputValueByArg(obj, 0)) - obj.getFieldValue(this);
    }
}

package network.aika.fields;

import network.aika.fields.defs.FieldLinkDefinitionOutputSide;
import network.aika.type.Obj;
import network.aika.type.Type;

/**
 * @author Lukas Molzberger
 */
public class FieldActivationFunction extends AbstractFunctionDefinition {

    private ActivationFunction actFunction;


    public static FieldActivationFunction actFunc(Type ref, String name, ActivationFunction actF, Double tolerance) {
        return new FieldActivationFunction(
                ref,
                name,
                actF,
                tolerance
        );
    }

    public FieldActivationFunction(Type ref, String name, ActivationFunction actFunction, Double tolerance) {
        super(ref, name, 1);

        this.tolerance = tolerance;
        this.actFunction = actFunction;
    }

    @Override
    protected double computeUpdate(Obj obj, FieldLinkDefinitionOutputSide fl, double u) {
        double value = obj.getOrCreateFieldInput(this).getValue();
        return actFunction.f(fl.getUpdatedInputValue(obj)) - value;
    }
}

package network.aika.fields;

import network.aika.fields.defs.FieldLinkDefinitionOutputSide;
import network.aika.type.Type;
import network.aika.type.Obj;

/**
 * @author Lukas Molzberger
 */
public class IdentityFunction extends AbstractFunctionDefinition {


    public static IdentityFunction identity(Type ref, String name) {
        return new IdentityFunction(
                ref,
                name
        );
    }

    public IdentityFunction(Type ref, String name) {
        super(ref, name, 1);
    }

    @Override
    protected double computeUpdate(Obj obj, FieldLinkDefinitionOutputSide fl, double u) {
        return u;
    }
}


package network.aika.fields;

import network.aika.fields.defs.FieldLinkDefinitionOutputSide;
import network.aika.type.Type;
import network.aika.type.Obj;

/**
 * @author Lukas Molzberger
 */
public class InputField extends AbstractFunctionDefinition {


    public static InputField inputField(Type ref, String name) {
        return new InputField(
                ref,
                name
        );
    }

    public InputField(Type ref, String name) {
        super(ref, name, 0);
    }

    @Override
    protected double computeUpdate(Obj obj, FieldLinkDefinitionOutputSide fl, double u) {
        return 0;
    }
}



package network.aika.fields;

import network.aika.fields.defs.FieldLinkDefinitionOutputSide;
import network.aika.type.Type;
import network.aika.type.Obj;

/**
 * @author Lukas Molzberger
 */
public class InvertFunction extends AbstractFunctionDefinition {

    public static InvertFunction invert(Type ref, String name) {
        return new InvertFunction(
                ref,
                name
        );
    }

    public InvertFunction(Type ref, String name) {
        super(ref, name, 1);

//        setInitialValue(1.0);
    }

    @Override
    protected double computeUpdate(Obj obj, FieldLinkDefinitionOutputSide fl, double u)  {
        double value = obj.getOrCreateFieldInput(this).getValue();
        return (1.0 - fl.getUpdatedInputValue(obj)) - value;
    }
}


package network.aika.fields;

import network.aika.fields.defs.FieldLinkDefinitionOutputSide;
import network.aika.fields.field.Field;
import network.aika.type.Type;
import network.aika.type.Obj;

/**
 * @author Lukas Molzberger
 */
public class Multiplication extends AbstractFunctionDefinition {

    public static Multiplication mul(Type ref, String name) {
        return new Multiplication(
                ref,
                name
        );
    }

    public Multiplication(Type ref, String name) {
        super(ref, name, 2);
    }

    @Override
    public void initializeField(Field field) {
        Obj toObj = field.getObject();
        double valueArg0 = getInputValueByArg(toObj, 0);
        double valueArg1 = getInputValueByArg(toObj, 1);

        field.setValue(valueArg0 * valueArg1);
    }

    @Override
    protected double computeUpdate(Obj obj, FieldLinkDefinitionOutputSide fl, double u) {
        return u * getInputValueByArg(
                obj,
                fl.getArgument() == 0 ?
                                1 :
                                0
                );
    }
}



package network.aika.fields;

import network.aika.fields.defs.FieldLinkDefinitionOutputSide;
import network.aika.type.Type;
import network.aika.type.Obj;

/**
 * @author Lukas Molzberger
 */
public class ScaleFunction extends AbstractFunctionDefinition {

    public static ScaleFunction scale(Type ref, String name, double scale) {
        return new ScaleFunction(
                ref,
                name,
                scale
        );
    }

    private final double scale;

    public ScaleFunction(Type ref, String name, double scale) {
        super(ref, name, 1);

        this.scale = scale;
    }

    @Override
    protected double computeUpdate(Obj obj, FieldLinkDefinitionOutputSide fl, double u) {
        return scale * u;
    }
}



package network.aika.fields;

import network.aika.fields.defs.FieldDefinition;
import network.aika.type.Obj;
import network.aika.type.Type;
import network.aika.type.relations.RelationMany;
import network.aika.type.relations.RelationOne;

import static network.aika.fields.Division.div;
import static network.aika.fields.ExponentialFunction.exp;
import static network.aika.fields.SumField.sum;

/**
 * @author Lukas Molzberger
 */
public class SoftmaxFields {

    public static SoftmaxFields softmax(
                    Type inputRef,
                    Type normRef,
                    Type outputRef,
                    RelationMany normInputRelation,
                    RelationOne normOutputRelation,
                    RelationOne inputRelation,
                    String name
    ) {
        return new SoftmaxFields(
                inputRef,
                normRef,
                outputRef,
                normInputRelation,
                normOutputRelation,
                inputRelation,
                name);
    }

    private final ExponentialFunction inputs;
    private final FieldDefinition norm;
    private final FieldDefinition outputs;


    public SoftmaxFields(
            Type inputRef,
            Type normRef,
            Type outputRef,
            RelationMany normInputRelation,
            RelationOne normOutputRelation,
            RelationOne inputRelation,
            String name
    ) {
        inputs = exp(inputRef, name);
        norm = sum(normRef, name)
                .in(normInputRelation, inputs);

        outputs = div(outputRef, name)
                .in(inputRelation, inputs, 0)
                .in(normOutputRelation, norm, 1);
    }

    public ExponentialFunction getInputs() {
        return inputs;
    }

    public FieldDefinition getNorm() {
        return norm;
    }

    public FieldDefinition getOutputs() {
        return outputs;
    }
}



package network.aika.fields;

import network.aika.fields.defs.FieldLinkDefinitionOutputSide;
import network.aika.type.Type;
import network.aika.type.Obj;

/**
 * @author Lukas Molzberger
 */
public class Subtraction extends AbstractFunctionDefinition {

    public static Subtraction sub(Type ref, String name) {
        return new Subtraction(
                ref,
                name
        );
    }

    public Subtraction(Type ref, String name) {
        super(ref, name, 2);
    }

    @Override
    protected double computeUpdate(Obj obj, FieldLinkDefinitionOutputSide fl, double u) {
        return fl.getArgument() == 0 ? u : -u;
    }
}



package network.aika.fields;

import network.aika.fields.defs.VariableArgumentsFieldDefinition;
import network.aika.type.Obj;
import network.aika.type.Type;

import static network.aika.utils.ToleranceUtils.TOLERANCE;

/**
 * @author Lukas Molzberger
 */
public class SumField extends VariableArgumentsFieldDefinition {


    public static SumField sum(Type ref, String name) {
        return new SumField(
                ref,
                name,
                TOLERANCE
        );
    }

    public SumField(Type ref, String name, double tolerance) {
        super(ref, name, tolerance);
    }
}


package network.aika.fields;

import network.aika.fields.defs.FieldLinkDefinitionOutputSide;
import network.aika.type.Obj;
import network.aika.type.Type;


/**
 * @author Lukas Molzberger
 */
public class ThresholdOperator extends AbstractFunctionDefinition {

    public static ThresholdOperator threshold(Type ref, String name, double threshold, Comparison type) {
        return new ThresholdOperator(ref, name, threshold, type);
    }

    public static ThresholdOperator threshold(Type ref, String name, double threshold, Comparison type, boolean isFinal) {
        return new ThresholdOperator(ref, name, threshold, type, isFinal);
    }

    private double threshold;
    private ThresholdOperator.Comparison comparison;
    private boolean isFinal;

    public ThresholdOperator(Type ref, String name, double threshold, Comparison type) {
        super(ref, name, 1);
        this.threshold = threshold;
        this.comparison = type;
    }

    public ThresholdOperator(Type ref, String name, double threshold, Comparison type, boolean isFinal) {
        super(ref, name, 1);
        this.threshold = threshold;
        this.comparison = type;
        this.isFinal = isFinal;
    }

    public enum Comparison {
        ABOVE,
        BELOW,
        BELOW_OR_EQUAL,
        ABOVE_ABS
    }

    @Override
    protected double computeUpdate(Obj obj, FieldLinkDefinitionOutputSide fl, double u) {
        double value = obj.getOrCreateFieldInput(this).getValue();
        if(isFinal && value > 0.5)
            return 0.0;

        return threshold(fl.getUpdatedInputValue(obj)) - value;
    }

    protected double threshold(double x) {
        return switch (comparison) {
            case ABOVE -> x > threshold ? 1.0 : 0.0;
            case BELOW -> x < threshold ? 1.0 : 0.0;
            case BELOW_OR_EQUAL -> x <= threshold ? 1.0 : 0.0;
            case ABOVE_ABS -> Math.abs(x) > threshold ? 1.0 : 0.0;
        };
    }
}




package network.aika.fields.defs;

import network.aika.fields.field.Field;
import network.aika.type.relations.Relation;
import network.aika.type.relations.RelationOne;
import network.aika.type.Obj;
import network.aika.queue.ProcessingPhase;
import network.aika.type.Type;
import network.aika.utils.ToleranceUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Stream;

import static network.aika.fields.defs.FieldLinkDefinition.link;

/**
 * @author Lukas Molzberger
 */
public class FieldDefinition implements Comparable<FieldDefinition> {

    protected Integer fieldId;

    protected String name;

    protected List<FieldLinkDefinitionInputSide> outputs = new ArrayList<>();

    protected FieldDefinition parent;
    protected List<FieldDefinition> children = new ArrayList<>();

    protected Type objectType;

    protected Double tolerance;

    protected ProcessingPhase phase;
    protected boolean isNextRound;


    public FieldDefinition(Type objectType, String name) {
        this.name = name;
        this.objectType = objectType;

        objectType.setFieldDefinition(this);
    }

    public FieldDefinition(Type objectType, String name, double tolerance) {
        this(objectType, name);

        this.tolerance = tolerance;
    }

    public void setFieldId(int fieldId) {
        this.fieldId = fieldId;
    }

    public void transmit(Field targetField, FieldLinkDefinitionOutputSide fieldLink, double update) {
        receiveUpdate(targetField, update);
    }

    protected void receiveUpdate(Field field, double update) {
        if(!field.getObject().isInstanceOf(objectType))
            return;

        if(ToleranceUtils.belowTolerance(getTolerance(), update))
            return;

        field.receiveUpdate(update);
    }

    public FieldDefinition getParent() {
        return parent;
    }

    public FieldDefinition setParent(FieldDefinition parent) {
        this.parent = parent;
        parent.children.add(this);

        return this;
    }

    public List<FieldDefinition> getChildren() {
        return children;
    }

    public boolean isFieldRequired(Set<FieldDefinition> fieldDefs) {
        return resolveInheritedFieldDefinition(fieldDefs) == this;
    }

    public FieldDefinition resolveInheritedFieldDefinition(Set<FieldDefinition> fieldDefs) {
        return children.stream()
                .filter(fieldDefs::contains)
                .map(fd ->
                        fd.resolveInheritedFieldDefinition(fieldDefs)
                )
                .findFirst()
                .orElse(this);
    }

    public void initializeField(Field field) {
        field.getObject()
                .getType()
                .getFlattenedTypeInputSide()
                .followLinks(field);
    }

    public void addInput(FieldLinkDefinitionOutputSide fl) {
        throw new UnsupportedOperationException();
    }

    public Stream<FieldLinkDefinitionOutputSide> getInputs() {
        throw new UnsupportedOperationException();
    }

    public void addOutput(FieldLinkDefinitionInputSide fl) {
        outputs.add(fl);
    }

    public Stream<FieldLinkDefinitionInputSide> getOutputs() {
        return outputs.stream();
    }

    public FieldDefinition out(RelationOne relation, FixedArgumentsFieldDefinition output, int arg) {
        link(this, output, relation, arg);

        assert relation != null || objectType.isInstanceOf(output.objectType) || output.objectType.isInstanceOf(objectType);

        return this;
    }

    public FieldDefinition out(Relation relation, VariableArgumentsFieldDefinition output) {
        link(this, output, relation, null);

        assert relation != null || objectType.isInstanceOf(output.objectType) || output.objectType.isInstanceOf(objectType);

        return this;
    }

    public FieldDefinition setName(String name) {
        this.name = name;

        return this;
    }

    public String getName() {
        return name;
    }

    public Type getObjectType() {
        return objectType;
    }

    public Integer getId() {
        return fieldId;
    }

    public FieldDefinition setObjectType(Type objectType) {
        this.objectType = objectType;

        return this;
    }

    public Double getTolerance() {
        return tolerance;
    }

    public FieldDefinition setTolerance(Double tolerance) {
        this.tolerance = tolerance;

        return this;
    }

    public ProcessingPhase getPhase() {
        return phase;
    }

    public FieldDefinition setPhase(ProcessingPhase phase) {
        this.phase = phase;

        return this;
    }

    public boolean isNextRound() {
        return isNextRound;
    }

    public FieldDefinition setNextRound(boolean nextRound) {
        isNextRound = nextRound;

        return this;
    }

    public FieldDefinition setQueued(ProcessingPhase phase) {
        this.phase = phase;

        return this;
    }

    public String toString() {
        return getId() + ":" + name;
    }

    @Override
    public int compareTo(FieldDefinition fd) {
        return fieldId.compareTo(fd.fieldId);
    }
}
package network.aika.fields.defs;

import network.aika.fields.direction.Direction;
import network.aika.fields.field.Field;
import network.aika.type.Type;
import network.aika.type.relations.Relation;
import network.aika.type.Obj;
import network.aika.type.relations.RelationOne;


public abstract class FieldLinkDefinition {

    private final FieldDefinition originFD;
    private final FieldDefinition relatedFD;
    private final Relation relation;
    private final Direction direction;

    private final Integer argument;

    public static void link(FieldDefinition input, FieldDefinition output, Relation relation, Integer argument) {
        FieldLinkDefinitionOutputSide flo = new FieldLinkDefinitionOutputSide(output, input, relation.getReverse(), Direction.OUTPUT, argument);
        FieldLinkDefinitionInputSide fli = new FieldLinkDefinitionInputSide(input, output, relation, Direction.INPUT, argument);

        output.addInput(flo);
        input.addOutput(fli);

        flo.setInputSide(fli);
        fli.setOutputSide(flo);
    }

    public FieldLinkDefinition(
            FieldDefinition originFD,
            FieldDefinition relatedFD,
            Relation relation,
            Direction direction,
            Integer argument
    ) {
        this.originFD = originFD;
        this.relatedFD = relatedFD;
        this.relation = relation;
        this.direction = direction;
        this.argument = argument;
    }

    public FieldLinkDefinition(
            FieldDefinition originFD,
            FieldDefinition relatedFD,
            Relation relation,
            Direction direction
    ) {
        this(originFD, relatedFD, relation, direction, null);
    }

    public FieldDefinition getOriginFD() {
        return originFD;
    }

    public FieldDefinition getRelatedFD() {
        return relatedFD;
    }

    public Relation getRelation() {
        return relation;
    }

    public Direction getDirection() {
        return direction;
    }

    public int getArgument() {
        return argument;
    }

    @Override
    public String toString() {
        return originFD + " -- (" + relation + ") -> " + relatedFD;
    }
}
package network.aika.fields.defs;

import network.aika.fields.direction.Direction;
import network.aika.type.Obj;
import network.aika.type.Type;
import network.aika.type.relations.Relation;


public class FieldLinkDefinitionInputSide extends FieldLinkDefinition {

    private FieldLinkDefinitionOutputSide outputSide;

    public FieldLinkDefinitionInputSide(FieldDefinition input, FieldDefinition output, Relation relation, Direction direction, Integer argument) {
        super(input, output, relation, direction, argument);
    }

    public FieldLinkDefinitionInputSide(FieldDefinition input, FieldDefinition output, Relation relation, Direction direction) {
        super(input, output, relation, direction);
    }

    public FieldLinkDefinitionOutputSide getOutputSide() {
        return outputSide;
    }

    public void setOutputSide(FieldLinkDefinitionOutputSide outputSide) {
        this.outputSide = outputSide;
    }
}
package network.aika.fields.defs;

import network.aika.fields.direction.Direction;
import network.aika.fields.field.Field;
import network.aika.type.Obj;
import network.aika.type.relations.Relation;
import network.aika.type.relations.RelationOne;

public class FieldLinkDefinitionOutputSide extends FieldLinkDefinition {

    private FieldLinkDefinitionInputSide inputSide;

    public FieldLinkDefinitionOutputSide(FieldDefinition output, FieldDefinition input, Relation relation, Direction direction, Integer argument) {
        super(output, input, relation, direction, argument);
    }

    public FieldLinkDefinitionOutputSide(FieldDefinition output, FieldDefinition input, Relation relation, Direction direction) {
        super(output, input, relation, direction);
    }

    public Field getInputField(Obj obj) {
        var rt = (RelationOne) getRelation();
        Obj inputObj = rt.followOne(obj);

        return inputObj.getFieldOutput(getRelatedFD());
    }

    public double getInputValue(Obj obj) {
        Field f = getInputField(obj);
        return f != null ?
                f.getValue() :
                0.0;
    }

    public double getUpdatedInputValue(Obj obj) {
        Field f = getInputField(obj);

        return f != null ?
                f.getUpdatedValue() :
                0.0;
    }

    public FieldLinkDefinitionInputSide getInputSide() {
        return inputSide;
    }

    public void setInputSide(FieldLinkDefinitionInputSide inputSide) {
        this.inputSide = inputSide;
    }
}
package network.aika.fields.defs;



import network.aika.fields.direction.Direction;
import network.aika.type.relations.RelationOne;
import network.aika.type.Obj;
import network.aika.type.Type;

import java.util.Objects;
import java.util.stream.Stream;

import static network.aika.fields.defs.FieldLinkDefinition.link;

/**
 *
 * @author Lukas Molzberger
 */
public abstract class FixedArgumentsFieldDefinition extends FieldDefinition {

    private final FieldLinkDefinitionOutputSide[] inputs;

    public FixedArgumentsFieldDefinition(Type objectType, String name, int numArgs) {
        super(objectType, name);

        inputs = new FieldLinkDefinitionOutputSide[numArgs];
    }

    public FixedArgumentsFieldDefinition(Type objectType, String name, int numArgs, double tolerance) {
        super(objectType, name, tolerance);

        inputs = new FieldLinkDefinitionOutputSide[numArgs];
    }

    @Override
    public Stream<FieldLinkDefinitionOutputSide> getInputs() {
        return Stream.of(inputs)
                .filter(Objects::nonNull);
    }

    @Override
    public void addInput(FieldLinkDefinitionOutputSide fl) {
        inputs[fl.getArgument()] = fl;
    }

    public double getInputValueByArg(Obj obj, int arg) {
        var fl = inputs[arg];
        return fl.getInputValue(obj);
    }

    public double getUpdatedInputValueByArg(Obj obj, int arg) {
        var fl = inputs[arg];
        return fl.getUpdatedInputValue(obj);
    }

    public FixedArgumentsFieldDefinition in(RelationOne relation, FieldDefinition input, int arg) {
        link(input, this, relation.getReverse(), arg);

        assert relation != null || objectType.isInstanceOf(input.objectType) || input.objectType.isInstanceOf(objectType);

        return this;
    }
}



package network.aika.fields.defs;

import network.aika.fields.direction.Direction;
import network.aika.type.Obj;
import network.aika.type.relations.Relation;
import network.aika.type.Type;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

import static network.aika.fields.defs.FieldLinkDefinition.link;

/**
 *
 * @author Lukas Molzberger
 */
public class VariableArgumentsFieldDefinition extends FieldDefinition {

    protected List<FieldLinkDefinitionOutputSide> inputs = new ArrayList<>();

    public VariableArgumentsFieldDefinition(Type objectType, String name) {
        super(objectType, name);
    }

    public VariableArgumentsFieldDefinition(Type objectType, String name, double tolerance) {
        super(objectType, name, tolerance);
    }

    public VariableArgumentsFieldDefinition in(Relation relation, FieldDefinition input) {

        link(input, this, relation.getReverse(), null);

        return this;
    }

    @Override
    public Stream<FieldLinkDefinitionOutputSide> getInputs() {
        return inputs.stream();
    }

    public int size() {
        return inputs.size();
    }

    public void addInput(FieldLinkDefinitionOutputSide fl) {
        inputs.add(fl);
    }
}
package network.aika.fields.direction;

import network.aika.fields.defs.FieldDefinition;
import network.aika.fields.field.Field;
import network.aika.fields.defs.FieldLinkDefinition;
import network.aika.type.FlattenedType;
import network.aika.type.Obj;
import network.aika.type.Type;
import network.aika.type.relations.Relation;

import java.util.stream.Stream;


public interface Direction {

    Direction INPUT = new Input();
    Direction OUTPUT = new Output();

    int getDirectionId();

    Direction invert();

    Stream<? extends FieldLinkDefinition> getFieldLinkDefinitions(FieldDefinition fd);

    FlattenedType getFlattenedType(Type type);

   void transmit(Field originField, FieldLinkDefinition fl, Obj relatedObject);
}
package network.aika.fields.direction;

import network.aika.fields.defs.FieldDefinition;
import network.aika.fields.defs.FieldLinkDefinitionOutputSide;
import network.aika.fields.field.Field;
import network.aika.fields.defs.FieldLinkDefinition;
import network.aika.type.FlattenedType;
import network.aika.type.Obj;
import network.aika.type.Type;
import network.aika.type.relations.Relation;

import java.util.stream.Stream;

public class Input implements Direction {

    @Override
    public int getDirectionId() {
        return 0;
    }

    @Override
    public Direction invert() {
        return Direction.OUTPUT;
    }

    @Override
    public Stream<FieldLinkDefinitionOutputSide> getFieldLinkDefinitions(FieldDefinition fd) {
        return fd.getInputs();
    }

    public FlattenedType getFlattenedType(Type type) {
        return type.getFlattenedTypeInputSide();
    }

    @Override
    public void transmit(Field originField, FieldLinkDefinition fl, Obj relatedObject) {
        double inputFieldValue = relatedObject.getFieldValue(fl.getRelatedFD());
        fl.getOriginFD().transmit(originField, (FieldLinkDefinitionOutputSide) fl, inputFieldValue);
    }
}
package network.aika.fields.direction;

import network.aika.fields.defs.FieldDefinition;
import network.aika.fields.defs.FieldLinkDefinitionInputSide;
import network.aika.fields.defs.FieldLinkDefinitionOutputSide;
import network.aika.fields.field.Field;
import network.aika.fields.defs.FieldLinkDefinition;
import network.aika.type.FlattenedType;
import network.aika.type.Obj;
import network.aika.type.Type;
import network.aika.type.relations.Relation;

import java.util.stream.Stream;


public class Output implements Direction {

    @Override
    public int getDirectionId() {
        return 1;
    }

    @Override
    public Direction invert() {
        return Direction.INPUT;
    }

    @Override
    public Stream<FieldLinkDefinitionInputSide> getFieldLinkDefinitions(FieldDefinition fd) {
        return fd.getOutputs();
    }

    public FlattenedType getFlattenedType(Type type) {
        return type.getFlattenedTypeOutputSide();
    }

    @Override
    public void transmit(Field originField, FieldLinkDefinition fl, Obj relatedObject) {
        FieldLinkDefinitionOutputSide flo = ((FieldLinkDefinitionInputSide)fl).getOutputSide();
        fl.getRelatedFD().transmit(
                relatedObject.getOrCreateFieldInput(fl.getRelatedFD()),
                flo,
                originField.getUpdate()
        );
    }
}



package network.aika.fields.field;

import network.aika.fields.defs.FieldDefinition;
import network.aika.type.Obj;
import network.aika.queue.ProcessingPhase;
import network.aika.queue.Queue;
import network.aika.type.Type;
import network.aika.utils.FieldWritable;
import network.aika.utils.StringUtils;
import network.aika.utils.ToleranceUtils;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;

/**
 * @author Lukas Molzberger
 */
public class Field implements FieldInput, FieldOutput, FieldWritable {

    private final FieldDefinition fieldDefinition;

    private final short id;
    private final Obj object;

    protected double value;

    private double updatedValue;

    protected boolean withinUpdate;

    QueueInterceptor interceptor;

    public static boolean isTrue(FieldOutput f) {
        if(f == null)
            return false;

        return isTrue(f.getValue());
    }

    public static boolean isTrue(FieldOutput f, boolean updatedValue) {
        if(f == null)
            return false;

        return isTrue(
                updatedValue ?
                        f.getUpdatedValue() :
                        f.getValue()
        );
    }

    private static boolean isTrue(double v) {
        return v > 0.0;
    }


    public Field(Obj obj, FieldDefinition fd, short id) {
        this.object = obj;
        this.fieldDefinition = fd;
        this.id = id;
    }

    public short getId() {
        return id;
    }

    @Override
    public boolean isWithinUpdate() {
        return withinUpdate;
    }

    @Override
    public double getValue() {
        return value;
    }

    @Override
    public double getUpdatedValue() {
        return withinUpdate ?
                updatedValue :
                value;
    }

    @Override
    public Obj getObject() {
        return object;
    }

    public Field setQueued(Queue q, ProcessingPhase phase, boolean isNextRound) {
        interceptor = new QueueInterceptor(q, this, phase, isNextRound);
        return this;
    }

    @Override
    public FieldDefinition getFieldDefinition() {
        return fieldDefinition;
    }

    protected Double getTolerance() {
        return fieldDefinition.getTolerance();
    }

    @Override
    public String getName() {
        return fieldDefinition.getName();
    }

    public QueueInterceptor getInterceptor() {
        return interceptor;
    }

    public void setInterceptor(QueueInterceptor interceptor) {
        this.interceptor = interceptor;
    }


    public void setValue(double v) {
        withinUpdate = true;
        updatedValue = v;
        propagateUpdate();
    }

    public void triggerUpdate(double u) {
        if(ToleranceUtils.belowTolerance(getTolerance(), u))
            return;

        withinUpdate = true;
        updatedValue = value + u;
/*        if(updatedValue > -MIN_TOLERANCE && updatedValue < MIN_TOLERANCE) {
            updatedValue = 0.0; // TODO: Find a better solution to this hack
        }
*/
        propagateUpdate();
    }

    private void propagateUpdate() {
        object
                .getType()
                .getFlattenedTypeOutputSide()
                .followLinks(this);

        value = updatedValue;
        withinUpdate = false;
    }

    public double getUpdate() {
        return updatedValue - value;
    }

    @Override
    public void receiveUpdate(double u) {
        if(interceptor != null) {
            interceptor.receiveUpdate(u, false);
            return;
        }

        assert !withinUpdate;
        triggerUpdate(u);
    }

    @Override
    public void write(DataOutput out) throws IOException {
        out.writeDouble(value);
    }

    @Override
    public void readFields(DataInput in) throws IOException {
        value = in.readDouble();
    }

    @Override
    public String toString() {
        return getName() + ": " + getValueString();
    }

    public String getValueString() {
        return StringUtils.doubleToString(getValue());
    }
}



package network.aika.fields.field;

/**
 *
 * @author Lukas Molzberger
 */
public interface FieldInput extends UpdateListener {
}



package network.aika.fields.field;

import network.aika.fields.defs.FieldDefinition;
import network.aika.type.Obj;


/**
 * @author Lukas Molzberger
 */
public interface FieldOutput {

    String getName();

    FieldDefinition getFieldDefinition();

    Obj getObject();

    String getValueString();

    double getValue();

    double getUpdatedValue();

    boolean isWithinUpdate();

    default boolean exceedsThreshold() {
        return getUpdatedValue() > 0.0;
    }
}



package network.aika.fields.field;

import network.aika.queue.ProcessingPhase;
import network.aika.queue.Queue;
import network.aika.queue.steps.FieldUpdate;
import network.aika.queue.Step;

/**
 *
 * @author Lukas Molzberger
 */
public class QueueInterceptor {

    private ProcessingPhase phase;

    private FieldUpdate step;

    private Field field;

    private Queue queue;

    private boolean isNextRound;

    public QueueInterceptor(Queue q, Field f, ProcessingPhase phase, boolean isNextRound) {
        this.queue = q;
        this.field = f;
        this.phase = phase;
        this.isNextRound = isNextRound;
    }

    public FieldUpdate getStep() {
        return step;
    }

    public Field getField() {
        return field;
    }

    public boolean isNextRound() {
        return isNextRound;
    }

    private FieldUpdate getOrCreateStep() {
        if(step == null)
            step = new FieldUpdate<>(phase, this);

        return step;
    }

    public void receiveUpdate(double u, boolean replaceUpdate) {
        FieldUpdate s = getOrCreateStep();
        s.updateDelta(u, replaceUpdate);

        if(u != 0.0 && !s.isQueued()) {
            if(!Step.add(s)) {
                process(s);
            }
        }
    }

    public void process(FieldUpdate s) {
        step = null;
        field.triggerUpdate(s.getDelta());
    }

    public Queue getQueue() {
        return queue;
    }
}



package network.aika.fields.field;

/**
 * @author Lukas Molzberger
 */
public interface UpdateListener {

    void receiveUpdate(double u);
}



package network.aika.fields.sign;


/**
 *
 * @author Lukas Molzberger
 */
public class Negative implements Sign {

    @Override
    public Sign invert() {
        return POS;
    }

    @Override
    public int index() {
        return 1;
    }

    public String toString() {
        return "NEG";
    }
}



package network.aika.fields.sign;

/**
 *
 * @author Lukas Molzberger
 */
public class Positive implements Sign {
    @Override
    public Sign invert() {
        return NEG;
    }


    @Override
    public int index() {
        return 0;
    }

    public String toString() {
        return "POS";
    }
}




package network.aika.fields.sign;

/**
 *
 * @author Lukas Molzberger
 */
public interface Sign {

    Positive POS = new Positive();
    Negative NEG = new Negative();

    Sign[] SIGNS = new Sign[] {POS, NEG};

    Sign invert();

    static Sign getSign(double x) {
        return x >= 0.0 ? POS : NEG;
    }

    int index();
}



package network.aika.queue;


/**
 *
 * @author Lukas Molzberger
 */
public interface ProcessingPhase {

    int rank();

    boolean isDelayed();
}



package network.aika.queue;

import network.aika.exceptions.TimeoutException;
import network.aika.queue.keys.QueueKey;

import java.util.Collection;
import java.util.NavigableMap;
import java.util.TreeMap;
import java.util.function.Predicate;

/**
 *
 * @author Lukas Molzberger
 */
public class Queue {

    protected Step currentStep;

    private final NavigableMap<QueueKey, Step> queue = new TreeMap<>(QueueKey.COMPARATOR);

    private long timestampCounter = 0;

    private Timestamp timestampOnProcess = new Timestamp(0);

    public Long getTimeout(){
        return Long.MAX_VALUE;
    }

    public Timestamp getTimestampOnProcess() {
        return timestampOnProcess;
    }

    public Timestamp getCurrentTimestamp() {
        return new Timestamp(timestampCounter);
    }

    public Timestamp getNextTimestamp() {
        return new Timestamp(timestampCounter++);
    }

    public synchronized void addStep(Step s) {
        s.createQueueKey(
                getNextTimestamp(),
                getRound(s)
        );
        queue.put(s.getQueueKey(), s);
        s.setQueued(true);
    }

    private int getRound(Step s) {
        int round;
        if(s.getPhase().isDelayed())
            round = QueueKey.MAX_ROUND;
        else
            round = getCurrentRound();

        if(s.incrementRound())
            round++;

        return round;
    }

    public int getCurrentRound() {
        if(currentStep == null)
            return 0;

        int r = currentStep.getQueueKey().getRound();
        return r == QueueKey.MAX_ROUND ? 0 : r;
    }

    public synchronized void removeStep(Step s) {
        Step removedStep = queue.remove(s.getQueueKey());
        assert removedStep != null;
        s.setQueued(false);
    }

    public Collection<Step> getQueueEntries() {
        return queue.values();
    }

    public void process() {
        process(null);
    }

    public synchronized void process(Predicate<Step> filter) {
        long startTime = System.currentTimeMillis();

        while (!queue.isEmpty()) {
            checkTimeout(startTime);

            currentStep = queue.pollFirstEntry().getValue();
            currentStep.setQueued(false);

            timestampOnProcess = getCurrentTimestamp();
            if(filter == null || filter.test(currentStep))
                currentStep.process();

            currentStep = null;
        }
    }

    private void checkTimeout(long startTime) {
        Long timeout = getTimeout();
        if(timeout == null)
            return;

        long currentTime = System.currentTimeMillis();
        if (startTime + timeout < currentTime)
            throw new TimeoutException();
    }
}



package network.aika.queue;

/**
 *
 * @author Lukas Molzberger
 */
public interface QueueProvider {

    Queue getQueue();

}



package network.aika.queue;

import network.aika.queue.keys.QueueKey;


/**
 * @author Lukas Molzberger
 */
public abstract class Step<E extends QueueProvider> {

    protected boolean isQueued;
    protected QueueKey queueKey;

    public void setQueued(boolean queued) {
        isQueued = queued;
    }

    public boolean isQueued() {
        return isQueued;
    }

    public QueueKey getQueueKey() {
        return queueKey;
    }

    public abstract Queue getQueue();

    public boolean incrementRound() {
        return false;
    }

    public abstract void createQueueKey(Timestamp timestamp, int round);

    public abstract void process();

    public abstract ProcessingPhase getPhase();

    public static boolean add(Step s) {
        Queue q = s.getQueue();
        if(q == null)
            return false;

        q.addStep(s);
        return true;
    }

    public abstract E getElement();
}



package network.aika.queue;

/**
 *
 * @author Lukas Molzberger
 */
public class Timestamp implements Comparable<Timestamp> {

    public static Timestamp MIN = new Timestamp(0);
    public static Timestamp MAX = new Timestamp(Long.MAX_VALUE);
    public static Timestamp NOT_SET = new Timestamp(Long.MAX_VALUE);

    private long timestamp;

    public Timestamp(long ts) {
        this.timestamp = ts;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public String toString() {
        if(this == NOT_SET)
            return "NOT_SET";

        if(this == MIN)
            return "MIN";

        if(this == MAX)
            return "MAX";

        return "" + timestamp;
    }

    @Override
    public int compareTo(Timestamp ts) {
        return Long.compare(timestamp, ts.timestamp);
    }
}



package network.aika.queue.keys;

import network.aika.queue.ProcessingPhase;
import network.aika.queue.Timestamp;

import java.util.Comparator;


/**
 * @author Lukas Molzberger
 */
public class FieldQueueKey extends QueueKey {

    Comparator<FieldQueueKey> COMPARATOR = Comparator
            .comparingInt(k -> -k.sortValue);

    private final int sortValue;


    public FieldQueueKey(int round, ProcessingPhase phase, int sortValue, Timestamp currentTimestamp) {
        super(round, phase, currentTimestamp);
        this.sortValue = sortValue;
    }

    public int getSortValue() {
        return sortValue;
    }

    private String getSortValueAsString() {
        return getSortValue() == Integer.MAX_VALUE ?
                "MAX" :
                "" + getSortValue();
    }

    @Override
    public int compareTo(QueueKey qk) {
        return COMPARATOR.compare(this, (FieldQueueKey) qk);
    }

    @Override
    public String toString() {
        return "[r:" + getRoundStr() +
                ",p:" + getPhaseStr() +
                ",sv:" + getSortValueAsString() +
                ",ts:" + getCurrentTimestamp() +
                "]";
    }
}



package network.aika.queue.keys;


import network.aika.queue.ProcessingPhase;
import network.aika.queue.Timestamp;
import network.aika.utils.StringUtils;

import java.util.Comparator;
import java.util.function.Function;

/**
 * @author Lukas Molzberger
 */
public abstract class QueueKey implements Comparable<QueueKey> {

    public static final int MAX_ROUND = Integer.MAX_VALUE;

    public static final Comparator<QueueKey> COMPARATOR = Comparator
            .<QueueKey>comparingInt(k -> k.round)
            .thenComparingInt(k -> k.getPhase().rank())
            .thenComparing(Function.identity())
            .thenComparing(QueueKey::getCurrentTimestamp);

    private final int round;

    private final ProcessingPhase phase;

    private final Timestamp currentTimestamp;

    public QueueKey(int round, ProcessingPhase phase, Timestamp currentTimestamp) {
        this.round = round;
        this.phase = phase;
        this.currentTimestamp = currentTimestamp;
    }

    public int getRound() {
        return round;
    }

    protected String getRoundStr() {
        return StringUtils.roundToString(getRound());
    }

    public ProcessingPhase getPhase() {
        return phase;
    }

    protected String getPhaseStr() {
        return getPhase() + "-" + getPhase();
    }

    public Timestamp getCurrentTimestamp() {
        return currentTimestamp;
    }
}




package network.aika.queue.steps;

import network.aika.queue.*;
import network.aika.queue.keys.FieldQueueKey;
import network.aika.type.Obj;
import network.aika.fields.field.QueueInterceptor;
import network.aika.utils.ApproximateComparisonValueUtil;

import static network.aika.utils.StringUtils.doubleToString;
import static network.aika.utils.StringUtils.roundToString;


/**
 *
 * @author Lukas Molzberger
 */
public class FieldUpdate<E extends Obj & QueueProvider> extends Step<E> {

    private final QueueInterceptor interceptor;

    private final ProcessingPhase phase;

    private int sortValue = Integer.MAX_VALUE;

    private double delta = 0.0;

    public FieldUpdate(ProcessingPhase p, QueueInterceptor qf) {
        this.phase = p;
        this.interceptor = qf;
    }

    @Override
    public boolean incrementRound() {
        return interceptor.isNextRound();
    }

    private void updateSortValue(double delta) {
        int newSortValue = ApproximateComparisonValueUtil.convert(delta);
        if(Math.abs(sortValue - newSortValue) == 0)
            return;

        if(isQueued()) {
            Queue q = getQueue();
            q.removeStep(this);
            sortValue = newSortValue;
            q.addStep(this);
        } else
            sortValue = newSortValue;
    }

    public int getSortValue() {
        return sortValue;
    }

    public void updateDelta(double delta, boolean replaceUpdate) {
        if(replaceUpdate)
            this.delta = 0;

        this.delta += delta;

        updateSortValue(
                Math.abs(this.delta)
        );
    }

    public void reset() {
        delta = 0.0;
    }

    @Override
    public Queue getQueue() {
        return interceptor.getQueue();
    }

    @Override
    public void createQueueKey(Timestamp timestamp, int round) {
        queueKey = new FieldQueueKey(round, getPhase(), sortValue, timestamp);
    }

    @Override
    public void process() {
        interceptor.process(this);
    }

    @Override
    public ProcessingPhase getPhase() {
        return phase;
    }

    @SuppressWarnings("unchecked")
    @Override
    public E getElement() {
        return (E) interceptor.getField().getObject();
    }

    public double getDelta() {
        return delta;
    }

    public QueueInterceptor getInterceptor() {
        return interceptor;
    }

    public String toShortString() {
        return " Round:" + roundToString(getQueueKey().getRound()) +
                " Delta:" + doubleToString(delta);
    }

    public String toString() {
        return getElement() + " Delta:" + doubleToString(delta) +
                " Field: " + interceptor.getField() +
                " Ref:" + interceptor.getField().getObject();
    }
}



package network.aika.type;

import network.aika.fields.defs.FieldDefinition;
import network.aika.fields.defs.FieldLinkDefinition;
import network.aika.fields.direction.Direction;
import network.aika.fields.field.Field;
import network.aika.type.relations.Relation;
import network.aika.utils.ArrayUtils;

import java.util.*;
import java.util.stream.Stream;

/**
 *
 * @author Lukas Molzberger
 */
public class FlattenedType {

    private final Direction direction;
    private final Type type;

    private final short[] fields;
    private final FieldDefinition[][] fieldsReverse;
    private final int numberOfFields;

    private FlattenedTypeRelation[][] mapping;

    @SuppressWarnings("unchecked")
    private FlattenedType(Direction dir, Type type, Map<FieldDefinition, Short> fieldMappings, int numberOfFields) {
        this.direction = dir;
        this.type = type;
        this.numberOfFields = numberOfFields;

        fields = new short[type.getTypeRegistry().getNumberOfFieldDefinitions()];
        Arrays.fill(fields, (short) -1);

        Map<Short, List<FieldDefinition>> groupedMap = new HashMap<>();
        for (Map.Entry<FieldDefinition, Short> e : fieldMappings.entrySet()) {
            fields[e.getKey().getId()] = e.getValue();

            groupedMap.computeIfAbsent(e.getValue(), k -> new ArrayList<>())
                    .add(e.getKey());
        }

        fieldsReverse = new FieldDefinition[numberOfFields][];
        for(Map.Entry<Short, List<FieldDefinition>> e: groupedMap.entrySet()) {
            fieldsReverse[e.getKey()] = e.getValue().toArray(new FieldDefinition[0]);
        }
    }

    public static FlattenedType createInputFlattenedType(Type type, Set<FieldDefinition> fieldDefs) {
        Map<FieldDefinition, Short> fieldMappings = new TreeMap<>();

        List<FieldDefinition> requiredFields = fieldDefs
                .stream()
                .filter(fd -> fd.isFieldRequired(fieldDefs))
                .toList();

        for(short i = 0; i < requiredFields.size(); i++) {
            FieldDefinition fd = requiredFields.get(i);
            fieldMappings.put(fd, i);
        }

       return new FlattenedType(Direction.INPUT, type, fieldMappings, requiredFields.size());
    }

    public static FlattenedType createOutputFlattenedType(Type type, Set<FieldDefinition> fieldDefs, FlattenedType inputSide) {
        Map<FieldDefinition, Short> fieldMappings = new TreeMap<>();
        for(FieldDefinition fd: fieldDefs) {
            FieldDefinition resolvedFD = fd.resolveInheritedFieldDefinition(fieldDefs);
            short fieldIndex = inputSide.fields[resolvedFD.getId()];

            fieldMappings.put(fd, fieldIndex);
        }

        return new FlattenedType(Direction.OUTPUT, type, fieldMappings, inputSide.numberOfFields);
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    public void flatten() {
        mapping = new FlattenedTypeRelation[type.getRelations().length][];

        for(Relation rel: type.getRelations()) {
            FlattenedTypeRelation[] resultsPerRelation = new FlattenedTypeRelation[type.getTypeRegistry().getTypes().size()];
            for (Type relatedType : type.getTypeRegistry().getTypes()) {
                resultsPerRelation[relatedType.getId()] = flattenPerType(rel, relatedType);
            }

            if(!ArrayUtils.isAllNull(resultsPerRelation))
                mapping[rel.getRelationId()] = resultsPerRelation;
        }
    }

    private FlattenedTypeRelation flattenPerType(
            Relation relation,
            Type relatedType
    ) {
        List<FieldLinkDefinition> fieldLinks = Stream.of(fieldsReverse)
                .flatMap(Stream::of)
                .<FieldLinkDefinition>flatMap(direction::getFieldLinkDefinitions)
                .filter(fl ->
                        fl.getRelation().getRelationId() == relation.getRelationId()
                )
                .filter(fl ->
                        relatedType.isInstanceOf(fl.getRelatedFD().getObjectType())
                )
                .filter(fl ->
                        direction.invert().getFlattenedType(relatedType).fields[fl.getRelatedFD().getId()] >= 0
                )
                .toList();

        return fieldLinks.isEmpty() ?
                null :
                new FlattenedTypeRelation(this, fieldLinks);
    }

    public void followLinks(Field field) {
        for(int relationId = 0; relationId < mapping.length; relationId++) {
            FlattenedTypeRelation[] ftr = mapping[relationId];

            if(ftr != null) {
                Relation relation = type.getRelations()[relationId];

                relation.followMany(field.getObject())
                        .forEach(relatedObj ->
                                followLinks(
                                        ftr[relatedObj.getType().getId()],
                                        relatedObj,
                                        field
                                )
                        );
            }
        }
    }

    private void followLinks(FlattenedTypeRelation ftr, Obj relatedObj, Field field) {
        if(ftr != null)
            ftr.followLinks(direction, relatedObj, field);
    }

    public FieldDefinition[][] getFieldsReverse() {
        return fieldsReverse;
    }

    public short getFieldIndex(FieldDefinition fd) {
        return fields[fd.getId()];
    }

    public short getNumberOfFields() {
        return (short) fieldsReverse.length;
    }

    public Type getType() {
        return type;
    }

    public FieldDefinition getFieldDefinitionIdByIndex(short idx) {
        return fieldsReverse[idx][0];
    }
}
package network.aika.type;

import network.aika.fields.defs.FieldDefinition;
import network.aika.fields.direction.Direction;
import network.aika.fields.field.Field;
import network.aika.fields.defs.FieldLinkDefinition;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class FlattenedTypeRelation {

    FieldLinkDefinition[][] fieldLinks;

    public FlattenedTypeRelation(FlattenedType flattenedType, List<FieldLinkDefinition> fls) {
        Map<Integer, List<FieldLinkDefinition>> groupedByOriginFD =
                fls.stream()
                .collect(Collectors.groupingBy(fl ->
                        fl.getOriginFD().getId())
                );

        fieldLinks = new FieldLinkDefinition[flattenedType.getFieldsReverse().length][];
        for(short i = 0; i < fieldLinks.length; i++) {
            for(FieldDefinition fd : flattenedType.getFieldsReverse()[i]) {
                List<FieldLinkDefinition> list = groupedByOriginFD.get(fd.getId());
                if (list != null) {
                    fieldLinks[i] = list.toArray(new FieldLinkDefinition[0]);
                }
            }
        }
    }

    public void followLinks(Direction direction, Obj relatedObj, Field field) {
        FieldLinkDefinition[] fls = fieldLinks[field.getId()];
        if(fls != null) {
            for (FieldLinkDefinition fl : fls) {
                direction.transmit(
                        field,
                        fl,
                        relatedObj
                );
            }
        }
    }
}





package network.aika.type;

import network.aika.fields.defs.FieldDefinition;
import network.aika.fields.field.Field;
import network.aika.queue.Queue;
import network.aika.type.relations.Relation;

import java.util.stream.Stream;

/**
 *
 * @author Lukas Molzberger
 */
public interface Obj {

    void initFields();

    Type getType();

    Stream<? extends Obj> followManyRelation(Relation rel);

    Obj followSingleRelation(Relation rel);

    Field getOrCreateFieldInput(FieldDefinition fd);

    Field getFieldOutput(FieldDefinition fd);

    Stream<Field> getFields();

    Obj setFieldValue(FieldDefinition fd, double v);

    double getFieldValue(FieldDefinition fd);

    double getFieldUpdatedValue(FieldDefinition fd);

    Queue getQueue();

    String toKeyString();

    boolean isInstanceOf(Type objectType);
}



package network.aika.type;

import network.aika.fields.defs.FieldDefinition;
import network.aika.fields.field.Field;
import network.aika.queue.Queue;
import network.aika.queue.QueueProvider;
import network.aika.type.relations.Relation;
import network.aika.utils.Writable;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.util.Objects;
import java.util.stream.Stream;

/**
 * @author Lukas Molzberger
 */
public abstract class ObjImpl implements Obj, QueueProvider, Writable<TypeRegistry> {

    protected Type type;

    private Field[] fields;

    @SuppressWarnings("unchecked")
    public ObjImpl(Type type) {
        this.type = type;

        if(type != null)
            fields = new Field[type.getFlattenedTypeInputSide().getNumberOfFields()];
    }

    @Override
    public void initFields() {
        for(short i = 0; i < type.getFlattenedTypeInputSide().getNumberOfFields(); i++) {
            FieldDefinition fd = type.getFlattenedTypeInputSide().getFieldDefinitionIdByIndex(i);

            Field field = getOrCreateFieldInput(fd);
            fd.initializeField(field);
        }
    }

    @Override
    public Type getType() {
        return type;
    }

    @Override
    public Stream<Obj> followManyRelation(Relation rel) {
        return Stream.empty();
    }

    @Override
    public Obj followSingleRelation(Relation rel) {
        return null;
    }

    @Override
    public boolean isInstanceOf(Type t) {
        return type.isInstanceOf(t);
    }

    @Override
    public Field getFieldOutput(FieldDefinition fd) {
        short fieldIndex = type.getFlattenedTypeOutputSide().getFieldIndex(fd);

        return fields[fieldIndex];
    }

    @SuppressWarnings("unchecked")
    @Override
    public Field getOrCreateFieldInput(FieldDefinition fd) {
        short fieldIndex = type.getFlattenedTypeInputSide().getFieldIndex(fd);

        Field f = fields[fieldIndex];
        if(f == null) {
            f = fields[fieldIndex] = new Field(this, fd, fieldIndex);
        }

        return f;
    }

    @SuppressWarnings("unchecked")
    @Override
    public Obj setFieldValue(FieldDefinition fd, double v) {
        getOrCreateFieldInput(fd)
                .setValue(v);
        return this;
    }

    @Override
    public double getFieldValue(FieldDefinition fd) {
        Field f = getFieldOutput(fd);
        return f != null ?
                f.getValue() :
                0.0;
    }

    @Override
    public double getFieldUpdatedValue(FieldDefinition fd) {
        Field f = getFieldOutput(fd);
        return f != null ?
                f.getUpdatedValue() :
                0.0;
    }

    @Override
    public Stream<Field> getFields() {
        return Stream.of(fields)
                .filter(Objects::nonNull);
    }

    @Override
    public Queue getQueue() {
        return null;
    }

    @Override
    public void write(DataOutput out) throws IOException {
        // TODO: implement
    }

    @Override
    public void readFields(DataInput in, TypeRegistry m) throws IOException {
        // TODO: implement
    }

    @Override
    public String toKeyString() {
        return "";
    }

    @Override
    public String toString() {
        return "" + type;
    }
}



package network.aika.type;

import network.aika.fields.defs.FieldDefinition;
import network.aika.type.relations.Relation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

import static network.aika.type.FlattenedType.createInputFlattenedType;
import static network.aika.type.FlattenedType.createOutputFlattenedType;

/**
 * @author Lukas Molzberger
 */
public class Type {

    protected static final Logger LOG = LoggerFactory.getLogger(Type.class);

    public static final Comparator<Type> TYPE_COMPARATOR = Comparator.
            comparingInt(Type::getDepth)
            .thenComparing(Type::getId);

    private final short id;
    private final String name;

    protected final List<Type> parents = new ArrayList<>();
    protected final List<Type> children = new ArrayList<>();

    private final TypeRegistry registry;

    private final Set<FieldDefinition> fieldDefinitions = new HashSet<>();

    protected List<Relation> relations = new ArrayList<>();

    private Integer depth;

    private FlattenedType flattenedTypeInputSide;
    private FlattenedType flattenedTypeOutputSide;

    public Type(TypeRegistry registry, String name) {
        this.name = name;
        this.registry = registry;

        id = registry.register(this);
    }

    public short getId() {
        return id;
    }

    public boolean isAbstract() {
        return !children.isEmpty();
    }


    public Relation[] getRelations() {
        return relations.toArray(new Relation[0]);
    }

    public void initFlattenedType() {
        Set<FieldDefinition> fieldDefs = getCollectFlattenedFieldDefinitions();

        flattenedTypeInputSide = createInputFlattenedType(this, fieldDefs);
        flattenedTypeOutputSide = createOutputFlattenedType(this, fieldDefs, flattenedTypeInputSide);
    }

    public Set<FieldDefinition> getCollectFlattenedFieldDefinitions() {
        return collectTypes()
                .stream()
                .flatMap(t -> t.getFieldDefinitions().stream())
                .collect(Collectors.toSet());
    }

    public SortedSet<Type> collectTypes() {
        TreeSet<Type> sortedTypes = new TreeSet<>(TYPE_COMPARATOR);
        collectTypesRecursiveStep(sortedTypes);
        return sortedTypes;
    }

    public void collectTypesRecursiveStep(SortedSet<Type> sortedTypes) {
        parents.forEach(p ->
                p.collectTypesRecursiveStep(sortedTypes)
        );
        sortedTypes.add(this);
    }

    public Integer getDepth() {
        if(depth == null)
            depth = parents.stream()
                .mapToInt(Type::getDepth)
                .max()
                .orElse(0);

        return depth;
    }

    public boolean isInstanceOf(Obj obj) {
        return isInstanceOf(obj.getType());
    }

    public boolean isInstanceOf(Type type) {
        return this == type ||
                parents.stream().anyMatch(p ->
                        p.isInstanceOf(type)
                );
    }

    public String getName() {
        return name;
    }

    public TypeRegistry getTypeRegistry() {
        return registry;
    }

    public FlattenedType getFlattenedTypeInputSide() {
        if(flattenedTypeInputSide == null)
            throw new RuntimeException("Type has not been flattened yet. TypeRegistry.flattenTypeHierarchy() needs to be called beforehand.");

        return flattenedTypeInputSide;
    }

    public FlattenedType getFlattenedTypeOutputSide() {
        if(flattenedTypeOutputSide == null)
            throw new RuntimeException("Type has not been flattened yet. TypeRegistry.flattenTypeHierarchy() needs to be called beforehand.");

        return flattenedTypeOutputSide;
    }

    public void setFieldDefinition(FieldDefinition fieldDef) {
        fieldDef.setFieldId(registry.createFieldId());
        fieldDefinitions.add(fieldDef);
    }

    public Set<FieldDefinition> getFieldDefinitions() {
        return fieldDefinitions;
    }

    public <T extends Type> Type addParent(T p) {
        parents.add(p);
        p.children.add(this);

        return this;
    }

    public List<? extends Type> getParents() {
        return parents;
    }

    public List<? extends Type> getChildren() {
        return children;
    }

    protected <R> R getFromParent(Function<Type, R> f) {
        return parents.stream()
                .map(f)
                .filter(Objects::nonNull)
                .findFirst()
                .orElse(null);
    }

    public String toString() {
        return name;
    }
}



package network.aika.type;

import java.util.List;

/**
 *
 * @author Lukas Molzberger
 */
public interface TypeRegistry {

    short register(Type type);

    List<Type> getTypes();

    int createFieldId();

    Type getType(short typeId);

    int getNumberOfFieldDefinitions();

    void flattenTypeHierarchy();
}



package network.aika.type;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeSet;

import static network.aika.type.Type.TYPE_COMPARATOR;

/**
 *
 * @author Lukas Molzberger
 */
public class TypeRegistryImpl implements TypeRegistry {

    private List<Type> types = new ArrayList<>();

    private int fieldIdCounter = 0;

    @Override
    public short register(Type type) {
        short id = (short) types.size();
        types.add(type);
        return id;
    }

    @Override
    public Type getType(short typeId) {
        return types.get(typeId);
    }

    @Override
    public List<Type> getTypes() {
        return types;
    }

    @Override
    public int createFieldId() {
        return fieldIdCounter++;
    }

    @Override
    public int getNumberOfFieldDefinitions() {
        return fieldIdCounter;
    }

    @Override
    public void flattenTypeHierarchy() {
        TreeSet<Type> sortedTypes = new TreeSet<>(TYPE_COMPARATOR);

        sortedTypes.addAll(types);

        sortedTypes
                .forEach(Type::initFlattenedType);

        sortedTypes
                .forEach(t -> {
                    t.getFlattenedTypeInputSide().flatten();
                    t.getFlattenedTypeOutputSide().flatten();
                });
    }
}



package network.aika.type.relations;

import network.aika.type.Type;
import network.aika.type.Obj;

/**
 *
 * @author Lukas Molzberger
 */
public abstract class AbstractRelation implements Relation {

    private int relationId;
    protected String relationName;

    private Relation reversed;

    public AbstractRelation(int relationId, String relationName) {
        this.relationId = relationId;
        this.relationName = relationName;
    }

    @Override
    public int getRelationId() {
        return relationId;
    }

    @Override
    public void setReversed(Relation reversed) {
        this.reversed = reversed;
    }

    public Relation getReverse() {
        return reversed;
    }

    @Override
    public String toString() {
        return getRelationLabel() + " -> " + getReverse().getRelationLabel();
    }

}


package network.aika.type.relations;

import network.aika.type.Obj;

import java.util.stream.Stream;

/**
 *
 * @author Lukas Molzberger
 */
public interface Relation {

    int getRelationId();

    void setReversed(Relation reversed);

    Relation getReverse();

    Stream<? extends Obj> followMany(Obj fromObj);

    boolean testRelation(Obj fromObj, Obj toObj);

    String getRelationLabel();
}


package network.aika.type.relations;

import network.aika.type.Type;
import network.aika.type.Obj;

import java.util.function.Function;
import java.util.stream.Stream;

/**
 *
 * @author Lukas Molzberger
 */
public class RelationMany extends AbstractRelation {

    public RelationMany(int relationId, String relationName) {
        super(relationId, relationName);
    }

    public Stream<? extends Obj> followMany(Obj fromObj) {
        return fromObj.followManyRelation(this);
    }

    @Override
    public boolean testRelation(Obj fromObj, Obj toObj) {
        return getReverse().testRelation(toObj, fromObj);
    }

    @Override
    public String getRelationLabel() {
        return relationName + " (Many)";
    }
}



package network.aika.type.relations;

import network.aika.type.Type;
import network.aika.type.Obj;

import java.util.function.Function;
import java.util.stream.Stream;

/**
 *
 * @author Lukas Molzberger
 */
public class RelationOne extends AbstractRelation {

    public RelationOne(int relationId, String relationName) {
        super(relationId, relationName);
    }

    public Obj followOne(Obj fromObj) {
        return fromObj.followSingleRelation(this);
    }

    @Override
    public Stream<Obj> followMany(Obj fromObj) {
        Obj toObj = followOne(fromObj);
        return toObj != null ?
                Stream.of(toObj) :
                Stream.empty();
    }

    @Override
    public boolean testRelation(Obj fromObj, Obj toObj) {
        return followOne(fromObj) == toObj;
    }

    @Override
    public String getRelationLabel() {
        return relationName + " (One)";
    }
}



package network.aika.type.relations;

import network.aika.type.Obj;
import network.aika.type.Type;

import java.util.stream.Stream;

/**
 *
 * @author Lukas Molzberger
 */
public class RelationSelf extends RelationOne {

    public RelationSelf(int relationId, String relationName) {
       super(relationId, relationName);
    }

    @Override
    public void setReversed(Relation reversed) {
        throw new UnsupportedOperationException();
    }

    @Override
    public Relation getReverse() {
        return this;
    }

    @Override
    public Obj followOne(Obj fromObj) {
        return fromObj;
    }

    @Override
    public Stream<Obj> followMany(Obj fromObj) {
        return Stream.of(fromObj);
    }

    @Override
    public boolean testRelation(Obj fromObj, Obj toObj) {
        return fromObj == toObj;
    }
}



package network.aika.utils;


/**
 * @author Lukas Molzberger
 *
 */
public class ApproximateComparisonValueUtil {

    public static final double PRECISION = 1000.0;

    public static int convert(double newSortValue) {
        return (int) (PRECISION * newSortValue);
    }
}
package network.aika.utils;

public class ArrayUtils {

    public static boolean isAllNull(Object[] array) {
        for (Object element : array) {
            if (element != null) {
                return false; // As soon as a non-null element is found, return false
            }
        }
        return true; // If no non-null element is found, return true
    }
}



package network.aika.utils;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;

/**
 *
 * @author Lukas Molzberger
 */
public interface FieldWritable {

    /**
     * Serialize the fields of this object to <code>out</code>.
     *
     * @param out <code>DataOuput</code> to serialize this object into.
     * @throws IOException
     */
    void write(DataOutput out) throws IOException;

    /**
     * Deserialize the fields of this object from <code>in</code>.
     *
     * <p>For efficiency, implementations should attempt to re-use storage in the
     * existing object where possible.</p>
     *
     * @param in <code>DataInput</code> to deseriablize this object from.
     * @throws Exception
     */
    void readFields(DataInput in) throws Exception;

}


package network.aika.utils;

import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.Locale;

import static network.aika.queue.keys.QueueKey.MAX_ROUND;

/**
 *
 * @author Lukas Molzberger
 */
public class StringUtils {

    public static double TOLERANCE = 0.001;


    public static String doubleToString(Double x) {
        if(x == null)
            return "--";
        return doubleToString(x, "#.######");
    }

    public static String floatToString(Float d, String format) {
        if(d == null)
            return "--";
        DecimalFormat formatter = new DecimalFormat(format, DecimalFormatSymbols.getInstance(Locale.ENGLISH));
        formatter.setRoundingMode( RoundingMode.DOWN );
        return formatter.format(d);
    }

    public static String doubleToString(Double d, String format) {
        if(d == null)
            return "--";
        DecimalFormat formatter = new DecimalFormat(format, DecimalFormatSymbols.getInstance(Locale.ENGLISH));
        formatter.setRoundingMode( RoundingMode.DOWN );
        return formatter.format(d);
    }

    public static String roundToString(int r) {
        return r == MAX_ROUND ? "MAX" : "" + r;
    }

    public static String depthToSpace(int depth) {
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < depth; i++)
            sb.append(" ");
        return sb.toString();
    }
}


package network.aika.utils;

/**
 *
 * @author Lukas Molzberger
 */
public class ToleranceUtils {

    public static double TOLERANCE = 0.001;


    public static double sum(double[] a) {
        double sum = 0;
        for(int i = 0; i < a.length; i++)
            sum += a[i];
        return sum;
    }

    public static boolean belowTolerance(Double tolerance, double[] x) {
        if(x == null)
            return true;

        if(tolerance == null)
            return false;

        return Math.abs(sum(x)) < tolerance;
    }

    public static boolean belowTolerance(Double tolerance, double x) {
        if(x == 0.0)
            return true;

        if(tolerance == null)
            return false;

        return Math.abs(x) < tolerance;
    }
}


package network.aika.utils;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;


public interface Writable<M> {

    /**
     * Serialize the fields of this object to <code>out</code>.
     *
     * @param out <code>DataOuput</code> to serialize this object into.
     * @throws IOException
     */
    void write(DataOutput out) throws IOException;

    /**
     * Deserialize the fields of this object from <code>in</code>.
     *
     * <p>For efficiency, implementations should attempt to re-use storage in the
     * existing object where possible.</p>
     *
     * @param in <code>DataInput</code> to deseriablize this object from.
     * @throws Exception
     */
    void readFields(DataInput in, M m) throws Exception;

}